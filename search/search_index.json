{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to thinkofjava.io","text":"<p>The java concept which all Java programmers must be aware of.</p> <ol> <li>Java Fundamentals</li> <li>Operators and Assignments</li> <li>Flow control</li> <li>Declaration and access modifiers</li> <li>Interface and abstract class</li> <li>Object oriented programming</li> <li>Exception Handling</li> <li>Multi Threading</li> <li>Inner class</li> <li>Java Modifiers</li> <li>String, StringBuffer, StringBuilder</li> <li>Collection</li> <li>Generics</li> </ol>"},{"location":"fundamentals/","title":"Overview","text":""},{"location":"fundamentals/#java-language-fundamentals","title":"Java Language Fundamentals","text":"<ol> <li>Identifiers and Reserved words</li> <li>Data Types</li> <li>Literals</li> <li>Arrays</li> <li>Types of variable</li> <li>var arg methods</li> <li>main method</li> <li>command line argument</li> </ol>"},{"location":"fundamentals/1_identifiers/identifiers/","title":"Java Identifiers and Reserved words","text":""},{"location":"fundamentals/1_identifiers/identifiers/#java-identifiers","title":"Java Identifiers","text":"<p>A name in java program is called identifier which can be used for identification.</p> <p>It can be a method name, variable name, class name or label name.</p> <pre><code>//Example\n\nclass Test {\n    public static void main(String[] args) {\n        int x = 10;\n    }\n}\n</code></pre> <p>In this example, there are five identifiers</p> <ul> <li><code>Test</code> - class name</li> <li><code>main</code> - method name</li> <li><code>String</code> - Pre-defined class name</li> <li><code>args</code> - variable name of type String</li> <li><code>x</code> - variable name of type int</li> </ul>"},{"location":"fundamentals/1_identifiers/identifiers/#rules-for-defining-java-identifiers","title":"Rules for defining Java identifiers","text":"<p>1) The only allowed characters in Java identifiers are</p> <p>a to z  A to Z  0 to 9 and $, _ (underscore)</p> <p>Usage of any other character will result in compilation error.</p> <pre><code>String total_number; //valid\nString total#; //invalid\n</code></pre> <p>2) Identifiers cannot start with digits</p> <pre><code>String total123; //valid\nString 123total; //invalid\n</code></pre> <p>3) Java identifiers are case-sensitive, and of-course Java language itself is treated as a case-sensitive programming language.</p> <pre><code>class Test {\n    int number = 10;\n    int Number = 10;\n    int NUMBER = 10;\n\n    // In this example, all variable names are different, so all are valid\n}\n</code></pre> <p>4) There is no length limit for Java identifier, but it is not recommended to take too lengthy identifiers.</p> <p>5) We can't use reserved words as identifiers.</p> <p><pre><code>int x = 10; //valid\nint if = 10; //invalid\n</code></pre> 6) All pre-defined Java class names and interface names can be used as identifiers.</p> <p><pre><code>class Test {\n    public static void main(String[] args) {\n        int String = 888;\n        System.out.println(String); //prints 888\n\n        int Runnable = 999;\n        System.out.println(Runnable); //prints 999\n    }\n}\n</code></pre> Even though it's valid, but not good a programming practice. It reduces readability and creates confusion.</p> <p>Identify valid Java identifiers</p> <pre><code>String total_number; //valid\nString total#; //invalid\nString 123total; //invalid\nString total123; //valid\nString ca$h; //valid\nString _$_$_$_; //valid\nString all@hands; //invalid\nString Java2Share; //valid\nString Integer; //valid\nString Int; //valid\nString int; //invalid\n</code></pre>"},{"location":"fundamentals/1_identifiers/identifiers/#reserved-words","title":"Reserved words","text":"<p>In Java, some words are reserved to represent some meaning or functionality; such a type of words is called reserved words.</p> <pre><code>%%{init: {\"flowchart\": {\"htmlLabels\": false}} }%%\nflowchart TD\n    ReservedWords[\"Reserved Words (53)\"]\n    ReservedLiterals[\"Reserved Literals (3)\"]\n    Keywords[\"Keywords (50)\"]\n    UnusedWords[\"Unused Words (2)\"]\n    UsedWords[\"Used Words (48)\"]\n    ReservedWords--&gt;ReservedLiterals;\n    ReservedWords--&gt;Keywords;\n    ReservedLiterals--&gt;true;\n    ReservedLiterals--&gt;false;\n    ReservedLiterals--&gt;null;\n    Keywords--&gt;UnusedWords;\n    UnusedWords--&gt;goto\n    UnusedWords--&gt;const\n    Keywords--&gt;UsedWords</code></pre>"},{"location":"fundamentals/1_identifiers/identifiers/#keywords-for-data-types8","title":"Keywords for data types(8)","text":"<pre><code>byte\nshort\nint\nlong\nfloat\ndouble\nboolean \nchar\n</code></pre>"},{"location":"fundamentals/1_identifiers/identifiers/#keywords-for-flow-control-11","title":"Keywords for flow control (11)","text":"<pre><code>if\nelse\nswitch\ncase\ndefault\nwhile\ndo\nfor\nbreak\ncontinue\nreturn\n</code></pre>"},{"location":"fundamentals/1_identifiers/identifiers/#keywords-for-modifiers11","title":"Keywords for modifiers(11)","text":"<pre><code>public\nprivate\nprotected\nstatic\nfinal\nabstract\nsynchronized\nnative\nstrictfp // since 1.2v\ntransient\nvolatile\n</code></pre>"},{"location":"fundamentals/1_identifiers/identifiers/#keywords-for-exception-handling-6","title":"Keywords for Exception handling (6)","text":"<pre><code>try\ncatch\nfinally\nthrows\nthrow\nassert\n</code></pre>"},{"location":"fundamentals/1_identifiers/identifiers/#class-related-keywords-6","title":"Class related keywords (6)","text":"<pre><code>class\ninterface\nextends\nimplements\npackage\nimport\n</code></pre>"},{"location":"fundamentals/1_identifiers/identifiers/#object-related-keywords-4","title":"Object related keywords (4)","text":"<pre><code>new\ninstanceof\nsuper\nthis\n</code></pre>"},{"location":"fundamentals/1_identifiers/identifiers/#void-return-type-keyword1","title":"void return type keyword(1)","text":"<p>In Java, return type is mandatory. If a method doesn't return anything, then we have to declare that method with void return type.</p> <p>But in C language, return type is optional and default return type is int.</p>"},{"location":"fundamentals/1_identifiers/identifiers/#unused-keywords-2","title":"Unused keywords (2)","text":"<pre><code>goto\nconst\n</code></pre> <p>Usage of <code>goto</code> keyword created several problems in old language, hence Sun people banned this keyword in Java.</p> <p>Use <code>final</code> instead of <code>const</code>.</p> <p>Note: Unused keywords usage in Java will return compile time error.</p>"},{"location":"fundamentals/1_identifiers/identifiers/#reserved-literals-3","title":"Reserved literals (3)","text":"<pre><code>true  // value for boolean data type\nfalse // value for boolean data type\nnull // default value for object reference.\n</code></pre>"},{"location":"fundamentals/1_identifiers/identifiers/#enum-keyword-15v","title":"enum keyword (1.5v)","text":"<p>We can use enum to define a group of named constants.</p> <pre><code>enum Months {\n    JAN, FEB, MAR\n}\n</code></pre>"},{"location":"fundamentals/1_identifiers/identifiers/#conclusion","title":"Conclusion:","text":"<ul> <li>All 53 reserved words in Java contain only lower case alphabet.</li> <li>We have only <code>new</code> keyword and there is no <code>delete</code> keyword, because destruction of a useless object is the responsibility of garbage collector.</li> <li> <p>Following are new keywords in Java</p> <pre><code>strictfp // 1.2 version onwards\nassert // 1.4 version onwards\nenum // 1.5 version onwards\n</code></pre> </li> <li> <p><code>strictfp</code> but not <code>strictFp</code></p> </li> <li><code>instanceof</code> but not <code>instanceOf</code></li> <li><code>synchronized</code> but not <code>synchronize</code></li> <li><code>extends</code> but not <code>extend</code></li> <li><code>implements</code> but not <code>implement</code></li> <li><code>import</code> but not <code>imports</code></li> <li><code>const</code> but not <code>constant</code></li> </ul>"},{"location":"fundamentals/1_identifiers/identifiers/#which-of-the-following-list-contains-only-java-reserved-words","title":"Which of the following list contains only Java reserved words","text":"<p><pre><code>new, delete //invalid\ngoto, constant //invalid\nbreak, continue, return, exit //invalid\nfinal, finally, finalize //invalid\nthrows, throw, thrown //invalid\nnotify, notifyAll //invalid\nimplements, extends, imports //invalid\nsizeof, instanceof //invalid\ninstaceOf, strictFp //invalid\nbyte, short, Int //invalid\n</code></pre> </p>"},{"location":"fundamentals/2_datatype/datatypes/","title":"Data Types","text":"<p>In Java, every variable expression has some type. Every data type is clearly defined.</p> <p>Compiler should check every assignment for type compatibility. </p> <p>Because of the above reason, we can conclude Java language is a strongly typed programming language.</p> <p>Java is not considered as a pure object-oriented programming language because several OOPS features are not satisfied by Java (like operator overloading, multiple inheritance, etc.). Moreover, we depend on primitive datatypes which are non objects.</p>"},{"location":"fundamentals/2_datatype/datatypes/#primitive-data-types-8-types","title":"Primitive Data types (8 types)","text":"<ul> <li> <p>Non-Numeric data type (2 types)</p> <ul> <li>char</li> <li>boolean</li> </ul> </li> <li> <p>Numeric data types (6 types)</p> <ul> <li>Integral data types<ul> <li>byte</li> <li>short</li> <li>int</li> <li>long </li> </ul> </li> <li>Floating point data types<ul> <li>float </li> <li>double</li> </ul> </li> </ul> </li> </ul> <p>Except boolean and char, remaining data types are considered as signed data types because we can represent both positive and negative numbers.</p>"},{"location":"fundamentals/2_datatype/datatypes/#byte","title":"byte","text":"<p>Size: 1 byte (8 bits)</p> <p>MAX_VALUE: 127</p> <p>MIN_VALUE: -128</p> <p>Range: -128 to 127</p> <p></p> <p>The most significant bit act as signed bit. 0 indicate positive number and 1 indicate negative number.</p> <p>Positive number will be represented directly in memory, whereas negative number will be represented in two's compliment form.</p> <pre><code>//Examples:\n\nbyte b = 10; //valid\nbyte b = 127; //valid\n\nbyte b = 128; \n//Compile time Exception: Possible loss of precision \n//found: int, required: byte\n\nbyte b = 10.5; \n//Compile time Exception: Possible loss of precision \n//found: double, required: byte\n\nbyte b = true; \n//Compile time Exception: Incompatible types\n//found: boolean, required: byte\n\nbyte b = \"test\"; \n//Compile time Exception: Incompatible types\n//found: java.lang.String, required: byte\n</code></pre> <p>byte is the best choice, if we want to handle data in terms of streams, either from the file or from network (a file or network supported form is byte).</p>"},{"location":"fundamentals/2_datatype/datatypes/#short","title":"short","text":"<p>This is rarely used datatype in Java.</p> <p>Size: 2 bytes (16 bits)</p> <p>Range: -2<sup>15</sup> to 2<sup>15</sup> -1 [-32768 to 32767]</p> <pre><code>//Example:\n\nshort s = 32767; //valid\nshort s = 32768; //CE: Possible loss of precision, found: int, required: short\n</code></pre> <p>short datatype is the best suitable for 16-bit processor like 8085, but these processors are completely outdated and hence the corresponding short datatype is also outdated datatype.</p>"},{"location":"fundamentals/2_datatype/datatypes/#int","title":"int","text":"<p>This is the most commonly used datatype in Java.</p> <p>Size: 4 bytes (32 bits)</p> <p>Range: -2<sup>31</sup> to 2<sup>31</sup> - 1  [-2147483648 to 2147483647]</p> <pre><code>//Example: \n\nint x = 2147483647; //valid\nint x = 2147483648; //CE: integer number too large\n\nint x = 2147483648L; \n//CE: Possible loss of precision, found: long, required: int\n\nint x = true; //CE: incompatible datatype, found: boolean, required: int\n</code></pre>"},{"location":"fundamentals/2_datatype/datatypes/#long","title":"long","text":"<p>Sometimes integer may not enough to hold a large value then we can use long datatype.</p> <p>Size: 8 bytes (64 bits)</p> <p>Range: -2<sup>63</sup> to 2<sup>63</sup> - 1</p> <p>eg.</p> <p>The amount of distance traveled by light in 100 days, to hold this value, <code>int</code> may not enough.</p> <p><code>long l = 126000000000;</code></p> <p>The number of characters present in a big file may exceed int range, hence the return type of length method is long but not int.</p> <p><code>long l = file.length();</code></p> <p>Note: All above datatypes (byte, short, int, long) meant for representing integral values.  If we want to represent floating point values, then we should use floating point datatype.</p>"},{"location":"fundamentals/2_datatype/datatypes/#float","title":"float","text":"<p>If we want 5 to 6 decimal place of accuracy then we should use <code>float</code>. It follows single precision.</p> <p>Size: 4 bytes (32 bits)</p> <p>Range: -3.4e<sup>38</sup> to 3.4e<sup>38</sup></p>"},{"location":"fundamentals/2_datatype/datatypes/#double","title":"double","text":"<p>If we want 14 to 15 decimal place of accuracy then we should use <code>double</code> datatype. It follows double precision</p> <p>Size: 8 bytes (64 bits)</p> <p>Range: -1.7e<sup>308</sup> to 1.7e<sup>308</sup></p>"},{"location":"fundamentals/2_datatype/datatypes/#boolean","title":"boolean","text":"<p>Size: Not applicable [virtual machine dependent]</p> <p>Range: Not applicable [but allowed values are true and false]</p> <pre><code>boolean b = true; //valid\nboolean b = 0; // CE: incompatible types, found: int, required: boolean\n\nboolean b = True; \n//CE: cannot find symbol, symbol: variable True, location: class ClassName\n\nboolean b = \"true\"; \n//CE: incompatible types, found: java.lang.String, required: boolean\n</code></pre>"},{"location":"fundamentals/2_datatype/datatypes/#char","title":"char","text":"<p>Old languages (like c/c++) are ASCII based, and the number of allowed ASCII characters is less than or equal to 256. To represent these 256 characters, 8 bits(1 byte) is enough, hence the size of char in old language is one byte.</p> <p>But Java is Unicode-based,  and the number of different Unicode characters is greater than 256 and less than or equal to 65,536. To represent these many characters, 8 bits may not be enough. So it uses 16 bits, hence the size of <code>char</code> in Java is two bytes.</p> <p>Size: 2 bytes (16 bits)</p> <p>Range: 0 to 65,536</p>"},{"location":"fundamentals/2_datatype/datatypes/#summary-of-java-primitive-datatypes","title":"Summary of Java primitive datatypes","text":"Data type Size Range Wrapper class Default value byte 1 byte -2<sup>7</sup> to 2<sup>7</sup> - 1 Byte 0 short 2 bytes -2<sup>15</sup> to 2<sup>15</sup> - 1 Short 0 int 4 bytes -2<sup>31</sup> to 2<sup>31</sup> - 1 Integer 0 long 8 bytes -2<sup>63</sup> to 2<sup>63</sup> - 1 Long 0 float 4 bytes -3.4e38 to 3.4e38 Float 0 double 8 bytes -1.7e308 to 1.7e308 Double 0 char 2 bytes 0 to 65,536 Character 0 [represents space character] boolean NA NA [allowed values true/false] Boolean false <p>Note: <code>null</code> is default value for object reference, and we can't apply for primitive. If we try to use for primitive, we'll get compile time error.</p> <p><pre><code>//Example\nchar ch = null; //CE: incompatible types, found: &lt;null type&gt;, required: char\n</code></pre> </p>"},{"location":"fundamentals/3_literals/literals/","title":"Literals","text":"<p>A constant value which can be assigned to a variable is called literal.</p> <pre><code>int x = 10;\n// int --&gt; datatype/keyword\n// x --&gt; name of variable/identifier\n// 10 --&gt; constant value/literal\n</code></pre>"},{"location":"fundamentals/3_literals/literals/#integral-literal","title":"Integral Literal","text":"<p>For integral datatypes (byte, short, int, long) we can specify literal value in the following ways:</p> <ul> <li> <p>Decimal form (base 10)</p> <p>Allowed digits are 0 to 9</p> <p><code>int x = 10;</code></p> </li> <li> <p>Octal form (base 8)</p> <p>Allowed digits are 0 to 7. Literal value should be prefixed with 0 [zero]</p> <p><code>int x = 010;</code></p> </li> <li> <p>Hexadecimal form (base 16)</p> <p>Allowed digits are 0 to 9, a to f. For the extra digit (a to f) we can use both lower and upper case character.  This is one of very few areas where Java is not case-sensitive.</p> <p>The literal value should be prefixed with <code>0x</code> or <code>0X</code> [zero x]     </p> <p><code>int x = 0x10;</code></p> <p>These are only possible ways to specify literal value for integral data type.</p> </li> </ul> <p>Question: Which of the following declarations are valid</p> <pre><code>int x = 10; //valid\n\nint x = 0786; //CE: Integer number too large\n\nint x = 0777; //valid\n\nint x = 0xface; //valid\n\nint x = 0xbeer; //CE: '; expected'\n\nint x = 10, y = 010, z = 0x10;\nSystem.out.println(x+\"..\"+y+\"..\"+z); // 10..8..16\n</code></pre> <p>By default, every integral literal is of int type, but we can specify explicitly as long type by suffixed with <code>l</code> or <code>L</code></p> <pre><code>int x = 10; //valid\nlong l = 10L; //valid\n\nint x = 10L; // CE: possible loss of precision, found: long, required: int\n\nlong l = 10; // valid\n</code></pre> <p>There is no direct way to explicitly specify byte and short literals. However, they can be specified indirectly.  When assigning an integral literal to a byte variable, if the value falls within the byte range,  the compiler treats it as a byte literal. The same applies to short literals.</p> <pre><code>byte b = 10; //valid\n\nbyte b = 127; //valid\n\nbyte b = 128; // CE: possible loss of precision, found: int, required: byte\n</code></pre>"},{"location":"fundamentals/3_literals/literals/#floating-point-literals","title":"Floating point literals","text":"<p>By default, all floating-point literals are of type <code>double</code>, so they cannot be directly assigned to a float variable.  However, a floating-point literal can be specified as a float by appending <code>f</code> or <code>F</code> as a suffix. <pre><code>float f = 123.456; \n//CE: Possible loss of precision, fount: double, required: float\n\nfloat f = 123.456f; //valid\n\ndouble d = 123.456; //valid\n</code></pre> </p> <p>A floating-point literal can be explicitly specified as a <code>double</code> by appending <code>d</code> or <code>D</code> as a suffix.  However, this is optional since floating-point literals are <code>double</code> by default.</p> <p><pre><code>double d = 123.456d; //valid\n\nfloat f = 123.456d; \n//CE: Possible loss of precision, found: double, required: float\n</code></pre> </p> <p>Floating-point literals can be specified only in decimal form; they cannot be represented in octal or hexadecimal forms. <pre><code>double d = 123.456; //valid\n\ndouble d = 0123.456; //valid, treated as decimal literal\n\ndouble d = 0x123.456; //CE: Malformed floating point literal\n</code></pre> </p> <p>Integral literals can be directly assigned to floating-point variables, and these literals can be specified in decimal, octal, or hexadecimal forms. <pre><code>double d = 0777; //valid\n\ndouble d = 0786; //CE: integer number too large\n\ndouble d = 0786.0; //valid, treats as decimal integral literal\n\ndouble d = 10; //valid\n\ndouble d = 0xFACE; //valid\n\ndouble d = 0xFACE.0; //invalid\n</code></pre> </p> <p>Floating-point literals cannot be assigned to integral types directly. <pre><code>double d = 10; //valid\n\nint x = 10.0; //CE: Possible loss of precision, found: double, required: int\n</code></pre> </p> <p>Floating-point literals can also be represented in exponential form, also known as scientific notation. <pre><code>double d = 1.2e3; //valid\n\nfloat f = 1.2e3; \n// CE: Possible loss of precision, found: double, required: int\n</code></pre></p>"},{"location":"fundamentals/3_literals/literals/#boolean-literals","title":"boolean literals","text":"<p>The only allowed values for boolean datatype are <code>true</code> and <code>false</code>.</p> <pre><code>boolean b = true; //valid\n\nboolean b = 0; //CE: incompatible types, found:int, required: boolean\n\nboolean b = True; \n//CE: cannot find symbol, symbol: variable True, location: class ClassName\n\nboolean b = \"true\"; \n//CE: incompatible types: found: java.lang.String, required: boolean\n</code></pre>"},{"location":"fundamentals/3_literals/literals/#char-literals","title":"char literals","text":"<p>We can specify char literal as single character within single quotes.</p> <p><pre><code>char ch = 'a'; //valid\n\nchar ch = a; \n//CE: cannot find symbol, Symbol: variable a, location: class ClassName\n\nchar ch = \"a\"; \n//CE: incompatible types, found: java.lang.String, required: char\n\nchar ch = 'ab'; //CE: unclosed char literal 'ab', not closed statement 'ab'\n</code></pre> </p> <p>A character literal can be specified as an integral literal representing the Unicode value of the character.  This integral literal can be in decimal, octal, or hexadecimal form, but it must fall within the valid range of 0 to 65,535. <pre><code>char ch = 0xFACE; //valid\n\nchar ch = 0777; //valid\n\nchar ch = 65535; //valid\n\nchar ch = 65536; \n//CE: possible loss of precision, found: int, required: char\n</code></pre> </p> <p>We can represent char literal in Unicode representation which is nothing but '\\uxxxx'</p> <p><code>char ch = '\\u0061'; //represents char a</code></p> <p>Every escape character is valid char literal.</p> <pre><code>char ch = '\\n'; //valid\n\nchar ch = '\\t'; //valid\n\nchar ch = '\\m'; //CE: illegal escape character\n</code></pre> Escape character Description \\n New line \\t Horizontal tab \\r Carriage return \\b Backspace \\f Form feed \\' Single quote \\\" Double quote \\ Backslash <p>Question: Which of the following are valid?</p> <pre><code>char ch = 65536; //invalid\n\nchar ch = 0xBEER; //invalid\n\nchar ch = \\uFACE; //invalid\n\nchar ch = '\\uBEEF'; //valid\n\nchar ch = '\\m'; //invalid\n\nchar ch = '\\iface'; //invalid\n</code></pre>"},{"location":"fundamentals/3_literals/literals/#string-literal","title":"String literal","text":"<p>Any sequence of character within double quote is treated as string literal.</p> <p><code>String s = \"Java\"</code></p>"},{"location":"fundamentals/3_literals/literals/#v17-enhancement-with-respect-to-literals","title":"v1.7 Enhancement with respect to Literals","text":"<ul> <li> <p>Binary literals</p> <p>Until version 1.6, integral literals could be specified in the following forms:</p> <ul> <li>Decimal form</li> <li>Octal form</li> <li>Hexadecimal form</li> </ul> <p>But from 1.7v onwards, we can specify literal value even in binary form. Allowed digits are 0 and 1. Literal value should be prefixed with <code>0b</code> or <code>0B</code> [zero B]</p> <p><pre><code>int x = 0b1111;\nSystem.out.println(x); //15\n</code></pre> </p> </li> <li> <p>Usage of underscore symbol in numeric literals.</p> <p>From 1.7v onwards, we can use underscore symbol between digits of numeric literal</p> <pre><code>double d = 123456.789;\ndouble d = 1_23_456.7_8_9;\ndouble d = 123_456.7_8_9;\n</code></pre> <p>The main advantage of this approach is that readability of code will be improved. At the time of compilation, these underscore symbols will be removed automatically, hence after compilation the above example will become</p> <p><code>double d = 123456.789</code></p> <p>We can use more than one underscore symbol between digits</p> <pre><code>double d = 1__23_4_5__6.00;\ndouble d = 1___23.4_5;\n</code></pre> <p>We can use underscore symbol only between digits, anywhere else will get compile time error.</p> <pre><code>double d = _12_45.49; //invalid\n\ndouble d = 12_34_.4_9; //invalid\n\nduble d = 12_34.4_9_; //invalid\n</code></pre> <pre><code>graph LR\nbyte[\"byte&lt;br&gt; (1 byte)\"] --&gt; short[\"short &lt;br&gt;(2 byte)\"]\nshort --&gt; int[\"int &lt;br&gt;(4 byte)\"]\nchar[\"char (2 byte)\"] --&gt; int\nint --&gt; long[\"long &lt;br&gt; (8 byte)\"]\nlong --&gt; float[\"float&lt;br&gt; (4 byte)\"]\nfloat --&gt; double[\"double&lt;br&gt; (8 byte)\"]</code></pre> <p>Note: 8 byte long value we can assign to 4 byte float variable because both are following different memory representation internally.</p> <p><code>float f = 10L; //valid</code></p> </li> </ul> <p></p>"},{"location":"fundamentals/4_arrays/arrays/","title":"Arrays","text":""},{"location":"fundamentals/4_arrays/arrays/#introduction","title":"Introduction","text":"<p>An Array is an indexed collection, fixed numbers of homogeneous data elements.</p> <p>The main advantage is,  we can represent a huge number of values by using a single variable so that readability of code will be improved.</p> <p>But the disadvantage of Arrays is fixed in size,  i.e., once we create an array, there is no way of increasing or decreasing the size based on requirement.</p> <p>To use an array, we should compulsorily know the size in advanced, which may not always possible.</p>"},{"location":"fundamentals/4_arrays/arrays/#array-declaration","title":"Array declaration","text":""},{"location":"fundamentals/4_arrays/arrays/#one-dimensional","title":"One-dimensional","text":"<p><pre><code>int[] x;\nint []x;\nint x[];\n// all of the above are valid declaration, \n// but recommended is first case because name is clearly separated from type\n</code></pre> </p> <p>At the time of declaration, we cannot specify the size, otherwise will get compile time error. <pre><code>//Example:\nint[6] x; //invalid\nint[] x; //valid\n</code></pre></p>"},{"location":"fundamentals/4_arrays/arrays/#two-dimensional","title":"Two-dimensional","text":"<p><pre><code>int[][] x;\nint [][]x;\nint x[][];\nint[] []x;\nint[] x[];\nint []x[];\n// all of the above are valid declaration\n</code></pre> </p> <p>Which of the following are valid: <pre><code>int[] a, b;  //valid dimension a=1,b=1\nint[] a[], b; //valid dimension a=2,b=1\nint[] a[], b[]; //valid dimension a=2,b=2\nint[] []a, b;  // valid dimension a=2,b=2\nint[] []a, b[]; //valid dimension a=2,b=3\nint[] []a, []b; //invalid, compilation error.\n</code></pre> </p> <p>If we want to specify dimension before the variable, this facility is applicable only for the first variable in declaration. If we try to apply for the remaining variable, compile time error will be raised. <pre><code>int[] []a, []b, []c; //invalid\n</code></pre></p>"},{"location":"fundamentals/4_arrays/arrays/#three-dimensional","title":"Three-dimensional","text":"<pre><code>int[][][] a;\nint [][][]a;\nint a[][][];\nint[] [][]a;\nint[] []a[];\nint[] a[][]\nint[][] []a;\nint[][] a[];\nint [][]a[];\nint []a[][];\n//all of the above are valid declaration\n</code></pre>"},{"location":"fundamentals/4_arrays/arrays/#array-creation","title":"Array Creation","text":"<p>Every array in java is an object, hence we can create an array by using a new operator. <pre><code>int[] a = new int[3];\n</code></pre></p> <p><pre><code>int[] a = new int[3];\nSystem.out.println(\"class name: \" + a.getClass().getName()); \n// class name: [I\n</code></pre> </p> <p>For every array type, corresponding classes are available,  and these classes are part of the Java language and not available to the programmer level.</p> Array Type Corresponding class name int[] [I int[][] [[I double[] [D short[] [S byte[] [B boolean[] [Z"},{"location":"fundamentals/4_arrays/arrays/#array-loopholes","title":"Array loopholes","text":"<ol> <li> <p>At the time of array creation, compulsorily we should specify the size otherwise compile time error will be raised. <pre><code>int[] x = new int[]; //invalid\nint[] x = new int[3]; //valid\n</code></pre></p> </li> <li> <p>It is legal to have an array with size zero. <pre><code>int[] x = new int[0]; //valid\n</code></pre></p> </li> <li> <p>If we try to specify negative size, then NegativeArraySizeException will be raised at Runtime. <pre><code>int[] a = new int[-3]; //Runtime Exception: NegativeArraySizeException\n</code></pre></p> </li> <li> <p>To specify array size, the allowed datatypes are a byte, short, char, int. Specifying any other data type will raise compile time error. <pre><code>int[] x = new int[10]; //valid\n\nint[] x = new int['a']; //valid, size=97\n\nbyte b = 20;\nint[] x = new int[b]; //valid\n\nshort s = 30;\nint[] x = new int[s]; //valid\n\nint[] x = new int[10l]; \n//Invalid, CE: Possible loss of precision. Found: long, required: int\n</code></pre> Note: The maximum allowed array size in Java is Integer.MAX_VALUE, which is the maximum value of int datatype. <pre><code>int[] x = new int[2147483647]; //valid size\n\nint[] x = new int[2147483648]; // CE: Integer number too large.\n</code></pre> Even in the first case, we may get runtime exception if sufficient heap memory is not available.</p> </li> </ol>"},{"location":"fundamentals/4_arrays/arrays/#two-dimensional_1","title":"Two-dimensional","text":"<p>In java, a two-dimensional array is not implemented by using matrix style;  it follows an array of array approach for multidimensional array creation.</p> <p>The main advantage of this approach is improved memory utilization. <pre><code>int[][] x = new int[2][];\nx[0] = new int[2];\nx[1] = new int[3];\n</code></pre> </p> <p><pre><code>int x[][][] = new int[2][][];\nx[0] =  new int[3][0];\nx[0][0] = new int[1];\nx[0][1] = new int[2];\nx[0][2] = new int[3];\nx[1] = new int[2][2];\n</code></pre> </p> <p>Which of the following array declarations are valid? <pre><code>int[] a = new int[]; //invalid\nint[] a = new int[3]; //valid\nint[][] a = new int[][]; //invalid\nint[][] a = new int[3][]; //valid\nint[][] a = new int[][4]; //invalid\nint[][] a = new int[3][4]; //valid\nint[][][] a = new int[3][4][5]; //valid\nint[][][] a = new int[3][4][]; //valid\nint[][][] a = new int[3][][5]; //invalid\nint[][][] a = new int[][4][5]; //invalid\n</code></pre></p>"},{"location":"fundamentals/4_arrays/arrays/#array-initialization","title":"Array initialization","text":"<p>Once we create an array, every array element by default is initialized with default value. <pre><code>int[] x = new int[3];\nSystem.out.println(x); //prints [I@abcde\nSystem.out.println(x[0]); //prints 0\n</code></pre></p> <p>Note: whenever we try to print any reference variable, internally <code>toString()</code> method will be invoked,  which is implemented by default to return the string in the following form</p> <pre><code>ClassName@hascodeInHexForm\n</code></pre> <pre><code>int[][] x = new int[2][3];\nSystem.out.println(x); //[[I@abcdef\nSystem.out.println(x[0]); //[I@123456\nSystem.out.println(x[0][0]); //0\n\nint[][] x = new int[2][];\nSystem.out.println(x); //[[I@abcedf\nSystem.out.println(x[0]); //null\nSystem.out.println(x[0][0]); //RE: NullPointerException\n</code></pre> <p>If we try to perform any operation on null, then runtime exception called <code>NullPointerException</code> will be raised.</p> <p>Once we create an array, every element by default is initialized with default values.  We can override these default values with our customized values.</p> <pre><code>int[] x = new int[6];\nx[0] = 10;\nx[1] = 20;\nx[2] = 30;\nx[3] = 40;\nx[4] = 50;\nx[5] = 60;\nx[6] = 70; // RE: ArrayIndexOutOfBoundException\nx[-6] = 80; //RE: ArrayIndexOutOfBoundException\nx[2.5] = 90; //CE: Possible loss of precision, found: double, required: int\n</code></pre> <p>Note: If we are trying to access an array element with out-of-range index (either positive or negative int value) then runtime exception <code>ArrayIndexOutOfBoundsException</code> will be raised.</p>"},{"location":"fundamentals/4_arrays/arrays/#array-declaration-creation-and-initialization","title":"Array declaration, creation and initialization","text":"<p>We can declare, create and initialize an array in a single line (shortcut representation)</p> <p><pre><code>int[] x;\nx = new int[1];\nx[0] = 10;\n\nint[] x = {10};\n\nchar[] ch = {'a', 'e', 'i', 'o', 'u'};\n\nString[] s = {\"A\", \"B\", \"C\"};\n</code></pre> </p> <p>We can use this shortcut for multidimensional arrays as well. <pre><code>int[][] x = {{10,20},{30,40,50}};\n</code></pre></p> <p>If we want to use this shortcut, compulsorily we should perform all activities in a single line.  If we try to divide into multiple lines, then we will get compile time error.</p>"},{"location":"fundamentals/4_arrays/arrays/#length-vs-length","title":"length vs length()","text":"<p>length is a final variable applicable for arrays. length variable represents the size of array.</p> <p><pre><code>int[] x = new int[6];\nSystem.out.println(x.length()); \n//CE: cannot find symbol. Symbol: method length(), location: class int[]\n\nSystem.out.println(x.length); //6\n</code></pre> </p> <p>length() is the final method applicable for String object. length() the number of characters present in the String.</p> <pre><code>String s = \"Java\";\nSystem.out.println(s.length); \n//CE: cannot find symbol, symbol: variable length\n// location class java.lang.String\n\nSystem.out.println(s.length()); //4\n</code></pre> <p>Note: length variable applicable for Arrays, but not for String objects, whereas length() applicable for a String object but not for Arrays.</p> <pre><code>String[] s = {\"A\", \"AA\", \"AAA\"};\nSystem.out.println(s.length); //3\nSystem.out.println(s.length()); \n//CE: cannot find symbol. symbol: length() method, location class String[]\n\nSystem.out.println(s[0].length); \n//CE: cannot find symbol. symbol: variable length, \n// location: class java.lang.String\n\nSystem.out.println(s[0].length()); //1\n</code></pre> <p>In multidimensional array, length variable represents the size of base array but not total size.</p> <pre><code>int[][] x = new int[6][3];\nSystem.out.println(x.length); //6\nSystem.out.println(x[0].length); //3\n</code></pre>"},{"location":"fundamentals/4_arrays/arrays/#anonymous-array","title":"Anonymous array","text":"<p>Sometimes we can declare an array without name, such a type of nameless array is called anonymous array.  The main purpose of anonymous arrays is just for instant use (one time usage).</p> <p>We can create an anonymous array as follows <pre><code>new int[]{10,20,30,40};\n</code></pre> </p> <p>While creating anonymous arrays, we can't specify the size; otherwise compile time error will be thrown. <pre><code>new int[3]{10,20,30}; //invalid\n</code></pre> </p> <p>We can create multidimensional anonymous arrays <pre><code>new int[][] {{10,20},{30,40,50}};\n</code></pre></p> <p>Based on our requirement, we can give the name for an anonymous array then it is no longer anonymous.</p> <pre><code>int[] x = new int[]{10,20,30};\n</code></pre> <pre><code>class Test {\n    public static void main(String[] args){\n        sum(new int[]{10,20,30});\n    }\n    public static void sum(int[] x){\n        int total = 0;\n        for(int x1 : x) {\n            int total += x;\n        }\n        System.out.println(\"The sum: \"+total);\n    }\n}\n</code></pre> <p>In the above example, just to call <code>sum()</code> we require any array, but after completing <code>sum()</code> call, we are not using that array anymore,  hence for this one time requirement, an anonymous array is the best choice.</p>"},{"location":"fundamentals/4_arrays/arrays/#array-element-assignments","title":"Array element assignments","text":""},{"location":"fundamentals/4_arrays/arrays/#case-1","title":"Case 1:","text":"<p>In the case of primitive type array,  we can use any type as an array element which can be implicitly promoted to declared type.</p> <p><pre><code>int[] x = new int[6];\nx[0] = 10; //valid\nx[1] = 'a'; //valid\n\nbyte b = 20;\nx[2] = b; //valid\n\nshort s = 30;\nx[3] = s; //valid\n\nx[4] = 10l; //CE: Possible loss of precision, found long, required int.\n</code></pre> In the case of float type array, allowed datatypes are a byte, short, char, int, long, float.</p>"},{"location":"fundamentals/4_arrays/arrays/#case-2","title":"Case 2:","text":"<p>In the case of object type arrays, we can provide either declared type objects or its child class objects as an array element.</p> <pre><code>//Example 1\nObject[] a = new Object[10];\na[0] = new Object(); //valid\na[1] = new String(\"Java\"); //valid\na[2] = enw Integer(10); //valid\n\n//Example 2\nNumber[] n = new Number[10];\nn[0] = new Integer[10]; //valid\nn[1] = new Double(10.5); //valid\nn[2] = new String(\"Java\"); \n//Invalid, CE: Incompatible types, \n//             found java.lang.String, \n//             required java.lang.Number\n</code></pre>"},{"location":"fundamentals/4_arrays/arrays/#case-3","title":"Case 3:","text":"<p>For interface type array, an array element should be its implementation class objects.</p> <p><pre><code>//Example\nRunnable[] r = new Runnable[10];\nr[0] = new Thread(); //valid\nr[1] = new String(\"Java\"); \n//invalid, CE: incompatible type \n//             found: java.lang.String \n//             required: java.lang.Runnable\n</code></pre> </p> Array Type Allowed element type Primitive array Any type that can be implicitly promoted to declared type Object type arrays Either declared type or its child class objects Abstract class type arrays Its child class objects Interface type Array Its implementation class objects are allowed"},{"location":"fundamentals/4_arrays/arrays/#array-variable-assignments","title":"Array variable assignments","text":""},{"location":"fundamentals/4_arrays/arrays/#case-1_1","title":"Case 1:","text":"<p>Element level promotions are not applicable at array level.  E.g., a char element can be promoted to an int type whereas a char array cannot be promoted to an int array.</p> <p><pre><code>int[] x = {10, 20};\nchar[] ch = {'a', 'b'};\n\nint[] b = x; //valid\nint[] c = ch; \n//invalid, CE: incompatible types, found: char[], required: int[]\n</code></pre> </p> <p>Which of the following promotions will be performed automatically? <pre><code>char --&gt; int //yes\nchar[] --&gt; int[] //no\nint --&gt; double //yes\nint[] --&gt; double[] //no\nfloat --&gt; int //no \nfloat[] --&gt; int[] //no \nString --&gt; Object //yes\nString[] --&gt; Object[] //yes\n</code></pre> </p> <p>In the case of object type arrays, a child class type array can be promoted to a parent class type array. <pre><code>String[] s = {\"A\", \"B\"};\nObject[] o = s; //valid\n</code></pre></p>"},{"location":"fundamentals/4_arrays/arrays/#case-2_1","title":"Case 2:","text":"<p>Whenever we are assigning one array to another array, internal elements won't be copied, just reference variables will be re-assigned.</p> <pre><code>int[] a = {10, 20};\nint[] b = {30};\na = b; //valid\nb = a; //valid\n</code></pre>"},{"location":"fundamentals/4_arrays/arrays/#case-3_1","title":"Case 3:","text":"<p>Whenever we are assigning one array to another array, the dimension must be matched, for example, in the place of one dimension int array; we should provide one dimension array only, failure to do so will result in compile time exception.</p> <pre><code>int[][] a = new int[3][];\na[0] = new int[4][3]; \n// CE: incompatible types. found: int[][], required: int[] \n\na[0] = 10; \n//CE: incompatible types. found: int, required: int[]\n\na[0] = new int[2]; //valid\n</code></pre> <p>Note: Whenever we are assigning one array to another array, both dimension and types must be matched, but sizes are not required to match.</p> <p><pre><code>int[][] a = new int[4][3]; //creates 5 objects\na[0] = new int[4]; //creates one object\na[1] = new int[2]; //creates one object\n\na = new int[3][2]; //creates 4 objects\n</code></pre> In the above program, how many objects are created in total? --&gt; 11</p> <p>And how many objects eligible for GC? --&gt; 7</p> <p></p>"},{"location":"fundamentals/5_variables/variables/","title":"Types of variables","text":""},{"location":"fundamentals/5_variables/variables/#division-based-on-type","title":"Division based on type","text":"<p>Based on types of value represented by a variable, all variables are divided into two types.</p>"},{"location":"fundamentals/5_variables/variables/#primitive-variable","title":"Primitive variable","text":"<p>It can be used to represent primitive values.</p> <p>e.g. <code>int x = 10;</code></p>"},{"location":"fundamentals/5_variables/variables/#reference-variables","title":"Reference variables","text":"<p>It can be used to refer to an object.</p> <p>e.g. <code>Student s = new Student();</code></p>"},{"location":"fundamentals/5_variables/variables/#division-based-on-position","title":"Division based on position","text":"<p>Based on the position of declaration and behavior, all variables are divided into three types.</p>"},{"location":"fundamentals/5_variables/variables/#instance-variable","title":"Instance variable","text":"<ul> <li>If the value of a variable varied from object to object, such a type of variables is called instance variables.</li> <li>For every object, a separate copy of instance variable will be created.</li> <li>It should be declared within the class directly but outside any method/block/constructor.</li> <li>It will be created at the time of object creation and destroyed at the object destruction, hence the scope of instance variable is exactly the same as the scope of object.</li> <li>It will be stored in heap memory as part of an object.</li> <li>We can't access instance variable directly from static area but can be accessed by using object reference.</li> <li> <p>We can access instance variable directly from the instance area   <pre><code>class Test {\n  int x = 10;\n  public static void main(String[] args) {\n    System.out.println(x);\n    // CE: Non-static referenced from a static context\n\n    Test t1 = new Test();\n    System.out.println(t1.x); //prints 10\n  }\n\n  public void m1() {\n    System.out.println(x); //valid and prints 10;\n  }\n}\n</code></pre></p> </li> <li> <p>JVM will always provide default values, and we are not required to perform initialization explicitly.   <pre><code>class Test {\n\n  int x; \n  double d; \n  boolean b; \n  String s;\n\n  public static void main(String[] args) {\n    Test t = new Test();\n    System.out.println(\"Integer value: \"+t.x); //Integer value: 0\n    System.out.println(\"double value: \"+t.d); //double value: 0.0\n    System.out.println(\"boolean value: \"+t.b); //boolean value: false\n    System.out.println(\"String value: \"+t.s); //String value: false\n  }\n\n}\n</code></pre></p> </li> </ul>"},{"location":"fundamentals/5_variables/variables/#static-variable","title":"Static variable","text":"<ul> <li>If the value of a variable is not varying from object to object, then it is not recommended to declare as instance variable.    We should declare such a type of variable at class level by using static modifier.</li> <li>In case of instance variable, for every object a separate copy will be created, but in case of static variable, a single copy will be created at class level and shared by every object of class.</li> <li>It should be declared within the class directly but outside any method/block/constructor.</li> <li>It will be created at the time of class loading and destroyed at the time of class unloading, hence the scope of static variable is exactly the same as the scope of .class file.</li> </ul> <p>Execution of Java program:</p> <ul> <li> <p>java Test (hit Enter)</p> <ul> <li>Start JVM</li> <li>Create and start the main thread</li> <li>Locate Test.clas file</li> <li>Load Test.class --&gt; static variable creation</li> <li>Execute main()</li> <li>Unload Test.clas --&gt; static variable destruction</li> <li>Terminate the main thread</li> <li>Shutdown JVM</li> </ul> </li> <li> <p>It will be stored in the method area</p> </li> <li> <p>We can access static variables either by object reference or by class name. Within the same class, it is not required to use class and we can access directly.   <pre><code>class Test {\n\n  static int x = 10;\n\n  public static void main(String[] args) {\n    Test t = new Test();\n    System.out.println(\"Access static variable using \" +\n     \"object reference: \" + t.x); \n    //Access static variable using object reference: 10\n\n     System.out.println(\"Access static variable using \" +\n      \"class name: \" + Test.x);\n     //Access static variable using clas name: 10\n\n     System.out.println(\"Access static variable directly: \" + x);\n     //Access static variable directly: 10\n  }\n\n  public void m1() {\n    System.out.println(\"Access static variable \" +\n     \"from instance area: \" + x);\n    //Access static variable from instance area: 10\n  }\n}\n</code></pre></p> </li> <li> <p>We can access static variables directly from instance and static area.</p> </li> <li> <p>JMV will provide default value for static variables, and we are not required to perform initialization explicitly.   <pre><code>class Test {\n\n  static int x;\n  static double d;\n  static String s;\n\n  public static void main(String[] args) {\n    System.out.println(\"Default value of integer x: \" + x);\n    //Default value of integer x: 0\n    System.out.println(\"Default value of double d: \" + d);\n    //Default value of double d: 0.0\n    System.out.println(\"Default value of String s: \" + s); \n    //Default value of String s: null\n  }\n}\n</code></pre></p> </li> <li> <p>Static variables are also known as class level variables or fields.   <pre><code>class Test {\n\n  static int x = 10;\n  int y = 20;\n\n  public static void main(String[] args){\n    Test t1 = new Test();\n    t1.x = 30;\n    t1.y = 40;\n    System.out.println(t1.x + \"---\" + t1.y);\n    // 30 --- 40\n\n    Test t2 = new Test();\n    System.out.println(t2.x + \"---\" + t2.y);\n    // 30 --- 20\n  }\n}\n</code></pre></p> </li> </ul>"},{"location":"fundamentals/5_variables/variables/#local-variable","title":"Local variable","text":"<ul> <li>Sometime to meet a temporary need of programmer, we can declare variables inside a method, block or constructor. Such a type of variables is called local/temporary/stack/automatic variable.</li> <li>It will be stored inside stack memory.</li> <li>It will be created while executing the block in which it is declared.</li> <li> <p>Once block execution completes, automatically local variable will be destroyed; hence the scope of local variable is the block in which it is declared.   <pre><code>class Test {\n\n  public static void main(String[] args){\n    int i = 0;\n    for(int j = 0; j &lt; 3; j++) {\n      i = i + j;   \n    }\n    System.out.println(i + \"---\" + j);\n    //CE: cannot find symbol\n    // symbol: variable j\n    // location: class Test\n  }\n}\n</code></pre></p> </li> <li> <p>JVM won't provide default value for local variables, we should perform initialization before using that variable. If we are not using then, it is not required to perform initialization.   <pre><code>class Test {\n  public static void main(String[] args){\n    int x;\n    System.out.println(\"Hello\"); //Prints Hello\n  }\n}\n</code></pre> <pre><code>class Test {\n  public static void main(String[] args){\n    int x;\n    System.out.println(x);\n    //CE: variable x might not have been initialized.\n  }\n}\n</code></pre> <pre><code>class Test {\n  public static void main(String[] args){\n    int x;\n    if(args.length &gt; 0) {\n      x = 10;  \n    }\n    System.out.println(x);\n    //CE: variable x might not have been initialized.\n  }\n}\n</code></pre> <pre><code>class Test {\n  public static void main(String[] args){\n    int x;\n    if(args.length &gt; 0) {\n      x = 10;\n    } else {\n      x = 20;  \n    }\n    System.out.println(x);\n  }\n}\n\njava Test A --&gt; 10\njava Test --&gt; 20\n</code></pre></p> </li> </ul> <p>Note:</p> <ul> <li>It is not recommended to perform initialization for local variable inside logical block, because there is no guarantee for the execution of these blocks always at runtime.</li> <li>It is highly recommended to perform initialization for local variables at the time of declaration at least with default value.</li> <li> <p>The only applicable modifier for local variable is final. If we try to apply any other modifier, then compiler time error will be raised.   <pre><code>class Test {\n  public static void main(String[] args){\n    public int x = 10; //illegal start of expression\n    private int y = 20; //illegal start of expression\n    protected int z = 30; //illegal start of expression\n    static int a = 40; //illegal start of expression\n    transient int b = 50; //illegal start of expression\n    volatile int c = 60; //illegal start of expression\n    final int d = 70; //valid\n  }\n}\n</code></pre></p> </li> <li> <p>If we are not declaring any modifier, then default access modifier is default, but this rule is applicable only for instance and static variable but not for local variable.</p> </li> </ul>"},{"location":"fundamentals/5_variables/variables/#summary","title":"Summary","text":"<ul> <li>For instance and static variable, JVM will provide default values, and we are not required to perform initialization explicitly,    but for local variables JVM won't provide default values, compulsory we should perform initialization before using that variable.</li> <li>Multiple threads can access instance and static variables simultaneously. Hence, these are not thread safe but in the case of local variables,    for every thread a separate copy will be created, so local variables are thread safe.</li> </ul> Type of variable Is thread-safe Instance variable No static variable No local variable Yes <ul> <li>Every variable in Java should be either instance, static or local.</li> <li> <p>Every variable in Java should be either primitive or reference.   Hence, various possible combinations of variables in Java are:   <pre><code>flowchart LR\nInstance --&gt; Primitive\nInstance --&gt; Reference\nStatic --&gt; Primitive\nStatic --&gt; Reference\nLocal --&gt; Primitive\nLocal --&gt; Reference</code></pre> <pre><code>class Test {\n  int x = 10; // instance primitive variable\n  static String s = \"Java\"; // static reference variable\n  public static void main(String[] args){\n    int[] y = new int[2]; //local reference variable\n  }\n}\n</code></pre></p> </li> <li> <p>Uninitialized array   <pre><code>class Test {\n  int [] x;\n  public static void main(String[] args){\n    Test t = new Test();\n    System.out.println(t.x); // null\n    System.out.println(t.x[0]); //RE: NullPointerException\n  }\n}\n</code></pre></p> </li> <li> <p>local level   <pre><code>int[] x;\nSystem.out.println(x); \n//CE: variable x might not have been initialized\nSystem.out.println(x[0]); \n//CE: variable x might not have been initialized\n</code></pre> <pre><code>int[] x = new int[2];\nSystem.out.println(x); // [I@253665\nSystem.out.println(x[0]); //0\n</code></pre>   Once we create an array, every array element by default is initialized with default values, irrespective of whether it is instance, static or local array.</p> </li> </ul>"},{"location":"fundamentals/6_varargs/var-args/","title":"var arg method","text":""},{"location":"fundamentals/6_varargs/var-args/#introduction","title":"Introduction","text":"<ul> <li>Also known as variable argument method.</li> <li>Until 1.4v, we can't declare a method with variable number of arguments if there is a change in the number of arguments,    we would have to declare a new method. It increases the length of code and reduces readability.</li> <li>To overcome this problem, the introduction of var-arg method happened in 1.5v. According to this, we can declare a method which can take variable number of arguments.    Such a type of methods is called var-arg methods.</li> <li> <p>We can declare a var-arg method as follows   <pre><code>public void method1(int... x);\n</code></pre>   We can call this method by passing any number of int values including zero numbers.   <pre><code>method1();\nmethod1(10);\nmethod1(10,20);\nmethod1(10,20,30);\n</code></pre></p> </li> <li> <p>Internally var-arg parameter will be converted into a one-dimensional array, hence within var-arg method; we can differentiate values by using index.   <pre><code>class Test {\n  public static void sum(int... x) {\n    int total = 0;\n    for(int x1 : x) {\n      total += x1;\n    }\n    System.out.println(\"The sum: \" + total);\n  }\n\n  public static void main(String[] args){\n    sum();            // The sum: 0\n    sum(10,20);       // The sum: 30\n    sum(10,20,30);    // The sum: 60\n    sum(10,20,30,40); // The sum: 100\n  }    \n}  \n</code></pre></p> </li> </ul>"},{"location":"fundamentals/6_varargs/var-args/#ways-to-declare-var-arg","title":"Ways to declare var-arg","text":""},{"location":"fundamentals/6_varargs/var-args/#case-1","title":"Case 1","text":"<p>Which of the following are valid var-arg method declaration? <pre><code>method1(int... x); //Valid\nmethod1(int ...x); //Valid\nmethod1(int...x); //Valid\nmethod1(int x...); //Invalid\nmethod1(int. ..x); //Invalid\nmethod1(int .x..); //Invalid\n</code></pre></p>"},{"location":"fundamentals/6_varargs/var-args/#case-2","title":"Case 2","text":"<p>We can mix var-arg parameter with normal parameter.</p> <pre><code>method1(int x, int... y);\nmethod1(String s, double... d);\n</code></pre>"},{"location":"fundamentals/6_varargs/var-args/#case-3","title":"Case 3","text":"<p>If we mix normal parameter with var-arg parameter, then var-arg parameter should be the last parameter. <pre><code>method1(char ch, String... s); //valid\nmethod1(double... d, String s); //Invalid\n</code></pre></p>"},{"location":"fundamentals/6_varargs/var-args/#case-4","title":"Case 4","text":"<p>Inside var-arg method, we can take only one var arg parameter.</p> <pre><code>method1(String s, int... x); //valid\nmethod1(int... x, double... y); //Invalid\n</code></pre>"},{"location":"fundamentals/6_varargs/var-args/#case-5","title":"Case 5","text":"<p>Inside a class, we can't declare var-arg method and corresponding one-dimensional array method simultaneously, otherwise compile time error will be raised. <pre><code>class Test {\n  public void method1(int... x) {\n    System.out.println(\"int...\");\n  }\n\n  public void method1(int[] x) {\n    System.out.println(\"int[]\");\n  }\n}\n\n//CE: cannot declare both method1(int...) and method1(int[]) in Test\n</code></pre></p>"},{"location":"fundamentals/6_varargs/var-args/#case-6","title":"Case 6","text":"<p><pre><code>class Test {\n  public static void method1(int... x) {\n    System.out.println(\"var-arg method\");  \n  }\n  public static void method(int x) {\n    System.out.println(\"Normal method\");  \n  }\n\n  public static void main(String[] args) {\n    method1(); // var-arg method\n    method1(10,20); // var-arg method\n    method1(10); // Normal method\n  }  \n}\n</code></pre> In general, the var-arg method will get the least priority, i.e., if no other method matched, then only var-arg method will get a chance.  It is exactly the same as the default case inside switch.</p>"},{"location":"fundamentals/6_varargs/var-args/#similarity-in-var-arg-and-one-dimensional-array","title":"Similarity in var-arg and one-dimensional array","text":""},{"location":"fundamentals/6_varargs/var-args/#case-1_1","title":"Case 1","text":"<p>Wherever a one-dimensional array is present in class, we can replace it with var-arg parameter. <pre><code>public static void main(String[] args);\n//the above method can be replaced with\npublic static void main(String... args);\n</code></pre></p>"},{"location":"fundamentals/6_varargs/var-args/#case-2_1","title":"Case 2","text":"<p>Wherever var-arg parameter is present, we can't replace it with one-dimensional array.</p> <pre><code>public void method1(int... x);\n//above method can't be replaced with\npublic void method1(int[] x);\n</code></pre> <p>Note: <code>method1(int... x)</code>  We can call this method by passing a group of int values and x will become one dimensional array</p> <p><code>method1(int[]... x)</code> We can call this method by passing a group of one-dimensional int arrays, and x will become two-dimensional int array.</p> <pre><code>class Test {\n  public static void main(String[] args) {\n    int[] a = {10, 20};\n    int[] b = {40, 50};\n    method1(a,b);\n  }\n  public static void method1(int[]... x) {\n    for(int[] x1: x) {\n      System.out.println(x1[0]);  \n    }\n  } \n}\n\n//Output\n//10\n//20\n</code></pre>"},{"location":"fundamentals/7_mainmethod/main-method/","title":"main method","text":""},{"location":"fundamentals/7_mainmethod/main-method/#introduction","title":"Introduction","text":"<ul> <li> <p>Whether the class contains the main method or not and whether the main method declared according to requirement or not,    the compiler won't check these things. At runtime, JVM is responsible to check these things.   If JVM unable to find the main method then RuntimeException with message <code>NoSuchMethodError: main</code> will be thrown.   <pre><code>class Test {\n}\n\n// --&gt; java Test\n//     RE: NoSuchMethodError: main\n</code></pre></p> </li> <li> <p>At runtime, JVM always searches for the main method with the following prototype:   <pre><code>public static void main(String[] args);\n\n// public: To call by JVM from anywhere\n// static: without existing object, JVM has to call this method\n// void: the main method won't return anything to JVM\n// main: This is the name configured inside JVM\n// String[]: to accept command line arguments if any\n</code></pre></p> </li> <li> <p>The above syntax is very strict, and if we perform any change then we will get runtime exception with message <code>NoSuchMethodError: main</code></p> </li> <li>Even though the above syntax is very strict, the following changes are acceptable:<ul> <li>Instead of <code>public static</code>, we can also use <code>static public</code> i.e., the order of modifier is not important.</li> <li>We can declare the String array in any acceptable form:<ul> <li>main(String[] args)</li> <li>main(String []args)</li> <li>main(String args[])</li> </ul> </li> <li>Instead of args param name, we can use any valid java identifier.<ul> <li>main(String[] xyz)</li> </ul> </li> <li>We can replace the String array with String var-arg parameter.</li> </ul> </li> <li>We can declare the main method with the following modifiers:<ul> <li>final</li> <li>synchronized</li> <li>strictfp   <pre><code>class Test {\n  static final synchronized strictfp \n  public void main(String[] args) {\n    System.out.println(\"Valid main method\");\n  }\n}\n</code></pre></li> </ul> </li> </ul>"},{"location":"fundamentals/7_mainmethod/main-method/#question-answer","title":"Question &amp; Answer","text":"<p>Which of the following main method declarations are valid?</p> <p><pre><code>public static void main(String args);   \n//Invalid: missing String[] argument\n\npublic static void Main(String[] args); \n//Invalid: Main and not main\n\npublic void main(String[] args);        \n//Invalid: missing static modifier\n\nfinal synchronized strictfp public void main(String[] args);\n//Invalid: missing static modifier\n\nfinal synchronized strictfp public static void main(String[] args);\n//valid\n\npublic static void main(String... args); \n//valid\n</code></pre> Question: In which of the above case we will get compile time error? Answer: We won't get compile time error in any of the cases but except the last two cases, we will get runtime exception </p> <p>Overloading of the main method is possible, but JVM will always call String[] argument main method.  The other overloaded method we have to call explicitly like normal method call. <pre><code>class Test {\n  public static void main(String[] args) {\n    System.out.println(\"String[]\");    \n  }  \n  public static void main(int[] args) {\n    System.out.println(\"int[]\");  \n  }\n}\n\n//Output: String[]\n</code></pre>  Inheritance concept is applicable for the main method, hence while executing child class if a child doesn't contain the main method,  then parent class main method will be executed. <pre><code>public class Parent {\n  public static void main(String[] args) {\n    System.out.println(\"Parent main\");      \n  }\n}\nclass Child extends Parent {\n\n}\n\n// compiling Parent class will result two class file \n// Parent.class and Child.class\n\n// Executing Parent class will result following output\n// Parent main\n\n// Executing Child class will also result same output\n// Parent main\n</code></pre></p> <pre><code>public class Parent {\n  public static void main(String[] args) {\n    System.out.println(\"Parent main\");      \n  }\n}\nclass Child extends Parent {\n  public static void main(String[] args) {\n    System.out.println(\"Child main\");      \n  }\n}\n\n// Here the main method declared in child class called\n// method hiding but not method overriding\n</code></pre> <p>Note: For the main method, inheritance and overloading concepts are applicable but not overriding. Instead of method overriding, it is method hiding.</p>"},{"location":"fundamentals/7_mainmethod/main-method/#17v-enhancement-wrt-main","title":"1.7v enhancement wrt main()","text":"<ul> <li>Until 1.6v, if class doesn't contain the main method, then the runtime exception with message <code>NoSuchMethodError: main</code> was thrown.   But from 1.7v onwards, we will get more elaborated error information   <code>Error: main method not found in class &lt;ClassName&gt;, please defin main method as public static void main(String[] args)</code></li> <li>The main method is mandatory in 1.7v to start program execution, hence even though class contains static block, it won't be executed if class does not contain the main method.</li> <li>Execution of program in 1.7v   <pre><code>graph TD\nA[Start] --&gt; B{\"Check for &lt;br&gt;main()\"};\nB --&gt; |\"Available\"| D[\"Identification of &lt;br&gt;static member\"]\nB --&gt; |\"Not available\"| C[\"Error: main method not found in class\"]\nD --&gt; E[\"Execution of static variable assignments &amp; static block\"]\nE --&gt; F[\"Execute main() method\"]</code></pre></li> </ul> <p>Question: Without writing main(), is it possible to print some statement to console? Answer: Yes, by using static block, but this rule was applicable until 1.6v. From 1.7v, it is impossible to print some statement to console without writing the main method.</p>"},{"location":"fundamentals/8_command_line/command-line/","title":"Command line arguments","text":""},{"location":"fundamentals/8_command_line/command-line/#introduction","title":"Introduction","text":"<p>The arguments which are passed from command prompt/Terminal are called command line arguments. With the command line arguments, JVM will create an array and pass that array as argument while calling the main method. <pre><code>java Test A B C\n\nA: argument one with index 0\nB: argument two with index 1\nC: argument three with index 2\n</code></pre></p> <p>The main goal of command line arguments is, we can customize the behavior of the main method.</p> <p>Let's understand the command line with a few examples:</p>"},{"location":"fundamentals/8_command_line/command-line/#example-1","title":"Example 1","text":"<pre><code>class Test {\n  public static void main(String[] args) {\n    for (int i = 0; i &lt;= args.length; i++) {\n        System.out.println(args[i]);\n    }\n  }  \n}\n\n//Executing the above code with the following input\njava Test A B C\n\n//Output:\nA\nB\nC\nArrayIndexOutOfBoundException\n\n//Even executing with the following command will return the same error\njava Test\n\n//Output:\nArrayIndexOutOfBoundException\n</code></pre>"},{"location":"fundamentals/8_command_line/command-line/#example-2","title":"Example 2","text":"<pre><code>class Test {\n  public static void main(String[] args) {\n    String[] argh = {\"x\", \"y\", \"z\"};\n    args = argh;\n    for (String s : args) {\n      System.out.println(s);  \n    }\n  }  \n}\n\njava Test A B C\n//Output\nx\ny\nz\n\njava Test\n//Output\nx\ny\nz\n</code></pre>"},{"location":"fundamentals/8_command_line/command-line/#example-3","title":"Example 3","text":"<p>within the main method, command line arguments are available in String form. <pre><code>class Test {\n  public static void main(String[] args) {\n    System.out.println(args[0]+args[1]);      \n  }\n}\n\njava Test 10 20\n//Output:\n1020\n</code></pre></p>"},{"location":"fundamentals/8_command_line/command-line/#example-4","title":"Example 4","text":"<p>Usually, space itself is the separator between command line arguments. If our argument contains space, then we need to enclose it within double quote.</p> <pre><code>class Test {\n  public static void main(String[] args) {\n    System.out.println(args[0]);      \n  }\n}\n\njava Test \"Note  Book\"\n//Output:\nNote Book\n</code></pre>"},{"location":"fundamentals/8_command_line/command-line/#java-coding-standards","title":"Java coding standards","text":"<ul> <li> <p>Whenever we are writing Java code, it is highly recommended to follow coding standards. Whenever we are writing any component,    its name should reflect the purpose of that component.   The main advantage of this approach is enhanced readability and maintainability.   <pre><code>class A {\n  public int m1(int x, int y) {\n    return x + y;\n  }\n}\n</code></pre>   The above code can be written better as follows:   <pre><code>public class Calculator {\n  public static int add(int num1, int num2) {\n    return num1 + num2;\n  }\n} \n</code></pre></p> </li> <li> <p>Standards for classes</p> <ul> <li>Generally class names are nouns.</li> <li>It should start with uppercase character, and if it contains multiple words, each inner word should start with uppercase character. <pre><code>String\nStringBuffer\nAccount\nDog\n</code></pre></li> </ul> </li> <li> <p>Standards for Interfaces</p> <ul> <li>Generally interface names are objective</li> <li>It should start with upper case character and if it contains multiple words, each inner word should start with uppercase character <pre><code>Runnable\nComparable\nSerializable\n</code></pre></li> </ul> </li> <li> <p>Standards for methods</p> <ul> <li>Generally, method names are either verbs or verb-noun combination.</li> <li>It should follow camelCase. <pre><code>print()\neat()\nsleep()\nstart()\n</code></pre></li> </ul> </li> <li> <p>Standards for variable</p> <ul> <li>Generally variable names are noun.</li> <li>It follows camelCase <pre><code>name\nage\nsalary\nmobileNumber\n</code></pre></li> </ul> </li> <li> <p>Standards for constants</p> <ul> <li>Generally constant names are nouns.</li> <li>It should contain only uppercase character, and if it contains multiple words, then these words are separated with underscore.</li> <li>We can declare constant with <code>public static final</code> modifier <pre><code>MAX_VALUE\nMAX_PRIORITY\nPI\n</code></pre></li> </ul> </li> </ul>"},{"location":"operators/","title":"Overview","text":""},{"location":"operators/#operators-and-assignments","title":"Operators and Assignments","text":"<ol> <li>Increment &amp; Decrement</li> <li>Arithmetic Operator</li> <li>String concatenation</li> <li>Relational Operators</li> <li>Equality operator</li> <li>instanceof operator</li> <li>Bitwise operator</li> <li>Short circuit operator</li> <li>Type cast operator</li> <li>Assignment operator</li> <li>Conditional operator</li> <li>new operator</li> <li>Operator precedence</li> <li>new vs newInstance()</li> <li>instanceof vs isInstance()</li> </ol>"},{"location":"operators/arithmetic/","title":"Arithmetic operators","text":""},{"location":"operators/arithmetic/#introduction","title":"Introduction","text":"<ul> <li>The arithmetic operators are (+, -, x, /, %)</li> <li>IF we apply any arithmetic operator between two variables a and b, the result type is always <code>max(int, type of a, type of b)</code></li> </ul> <pre><code>byte + byte = int\nbyte + short = int\nshort + short = int\nbyte + long = long\nlong + double = double\nfloat + long = float\nchar + char = int\nchar + double = double\nchar + double = double\n\nSystem.out.println('a' + 'b');//195\nSystem.out.println('a' + 0.89); //97.89\n</code></pre> <pre><code>graph LR\nbyte[\"byte&lt;br&gt; (1 byte)\"] --&gt; short[\"short &lt;br&gt;(2 byte)\"]\nshort --&gt; int[\"int &lt;br&gt;(4 byte)\"]\nchar[\"char (2 byte)\"] --&gt; int\nint --&gt; long[\"long &lt;br&gt; (8 byte)\"]\nlong --&gt; float[\"float&lt;br&gt; (4 byte)\"]\nfloat --&gt; double[\"double&lt;br&gt; (8 byte)\"]</code></pre>"},{"location":"operators/arithmetic/#infinity","title":"Infinity","text":"<p>In integral arithmetic (byte, short, int, long), there is no way to represent infinity, hence if infinity is the result, we will get ArithmeticException in integral arithmetic.</p> <pre><code>int d = 10/0; //RE: ArithmeticException: / by zero\n</code></pre> <p>But in floating point arithmetic (float, double), there is a way to represent infinity. For this float and double classes contain the following two constants</p> <pre><code>POSITIVE_INFINITY\nNEGATIVE_INFINITY\n</code></pre> <p>Hence, even though the result is infinity, we won't get any arithmetic exception in floating point arithmetic. <pre><code>System.out.println(10/0.0); //Infinity\nSystem.out.println(-10/0.0); //Infinity\n</code></pre></p>"},{"location":"operators/arithmetic/#nan-not-a-number","title":"NaN (Not a number)","text":"<p>In integral arithmetic, there is no way to represent an undefined result, hence if a result is undefined, we will get runtime exception as ArithmeticException</p> <pre><code>System.out.println(0/0);  //RE: ArithmeticException: / by zero\n</code></pre> <p>But in floating point arithmetic, there is a way to represent an undefined result.  The Float and Double wrapper classes contain NaN constant, hence if the result is undefined, we won't get any ArithmeticException.</p> <p><pre><code>System.out.println(0.0/0); //NaN\nSystem.out.println(-0.0/0); //NaN\n</code></pre> Note: For any value of x including NaN, the following expression returns false: <pre><code>float x = 10.0;\nSystem.out.println(x &lt; Float.NaN); //false\nSystem.out.println(x &lt;= Float.NaN); //false\nSystem.out.println(x &gt; Float.NaN); //false\nSystem.out.println(x &gt;= Float.NaN); //false\nSystem.out.println(x == Float.NaN); //false\nSystem.out.println(Float.NaN == Float.NaN); //false\n\nSystem.out.println(x != Float.NaN); //true\nSystem.out.println(Float.NaN != Float.NaN); //trues\n</code></pre></p>"},{"location":"operators/arithmetic/#arithmetic-exception","title":"Arithmetic Exception","text":"<ul> <li>It is a runtime exception but not compile time error.</li> <li>It is possible only in integral arithmetic but not in floating point arithmetic.</li> <li>The only operators which cause arithmetic exception are <code>/</code> and <code>%</code></li> </ul>"},{"location":"operators/assignment/","title":"Assignment Operator","text":"<p>There are three types of assignment operator</p>"},{"location":"operators/assignment/#simple-assignment","title":"Simple assignment","text":"<pre><code>int x = 10;\n</code></pre>"},{"location":"operators/assignment/#chained-assignment","title":"Chained assignment","text":"<p><pre><code>int a, b, c, d;\na = b = c = d = 20;\n</code></pre> Note: We cannot perform chained assignment directly at the time of declaration.</p>"},{"location":"operators/assignment/#compound-assignment-operator","title":"Compound assignment operator","text":"<p>Sometimes assignment operator mixed with other operators, such types of assignment operators are called compound assignment operator.</p> <pre><code>int a = 10;\na += 20;\nSystem.out.println(a); //30\n</code></pre> <p>The following various possible compound assignment operators in Java:</p> <pre><code>+=\n-=\n*=\n/=\n%=\n&amp;=\n!=\n^=\n&gt;&gt;=\n&gt;&gt;&gt;=\n&lt;&lt;=\n</code></pre> <p>In compound assignment operators, the compiler will perform the required type casting automatically.</p> <pre><code>byte b = 10;\nb = b + 1; \n//CE: Possible loss of precision, found:int, required:byte\n\nbyte b = 10;\nb++;\nSystem.out.println(b); //11\n\nbyte b = 10;\nb += 1; // ==&gt; b = (byte)(b+1)\nSystem.out.println(b); //11\n\nbyte b = 128;\nb += 3;\nSystem.out.println(b); //-126\n</code></pre> <pre><code>int a, b, c, d;\na = b = c = d = 20;\na += b -= c *= d/= 2;\nSystem.out.println(a +\"--\"+ b +\"--\"+ c +\"--\"+ d);\n//-160 -- -180 -- 200 -- 10\n\n//Assignment will be performed from right to left.\n</code></pre>"},{"location":"operators/bitwise/","title":"Bitwise Operator","text":""},{"location":"operators/bitwise/#bitwise-operators","title":"Bitwise operators (&amp;, |, ^)","text":"<p><code>&amp;</code> --&gt; AND --&gt; Returns true iff both arguments are true  <code>|</code> --&gt; OR --&gt; Returns true iff one argument is true  <code>^</code> --&gt; XOR --&gt; Returns true iff both arguments are different.</p> <pre><code>System.out.println(true &amp; false); //false\nSystem.out.println(true | false); //true\nSystem.out.println(true ^ false); //true\n</code></pre> <ul> <li>We can apply these operators for integral type as well.   <pre><code>System.out.println(4 &amp; 5); //4\n//Explanation: 4=100, 5=101, so (100 &amp; 101) = 100\n\nSystem.out.println(4 | 5); //5\n//Explanation: 4=100, 5=101, so (100 | 101) = 101\n\nSystem.out.println(4 ^ 5); //1\n//Explanation: 4=100, 5=101, so (100 ^ 101) = 001\n</code></pre></li> </ul>"},{"location":"operators/bitwise/#bitwise-complement-operator-tilde","title":"Bitwise complement operator (~ tilde)","text":"<ul> <li>We can apply this operator for integral types but not for boolean types, if we try to do so, a compile time error will be raised.   <pre><code>System.out.println(~true); //CE: operator ~ cannot be applied to boolean.\n</code></pre> <pre><code>System.out.println(~4); //-5\n//Explanation at: https://www.geeksforgeeks.org/bitwise-complement-operator-tilde/\n</code></pre></li> </ul> <p>Note:  - The most significant bit represents sign bit, 0 means positive, and 1 is negative. - Positive number will be represented directly in memory, whereas negative number will be represented indirectly in memory, in 2's complement form</p>"},{"location":"operators/bitwise/#boolean-complement-operator","title":"Boolean complement operator (!)","text":"<p>We can apply this operator only for boolean type.</p> <pre><code>System.out.println(!false); //true\n\nSystem.out.println(!4); //CE: operator ! cannot be applied to int\n</code></pre>"},{"location":"operators/conditional/","title":"Conditional Operator","text":""},{"location":"operators/conditional/#conditional-operator","title":"Conditional operator [?:]","text":"<p>The only available ternary operator in Java is conditional operator.</p>"},{"location":"operators/conditional/#syntax","title":"Syntax:","text":"<pre><code>Condition ? (executes when condition true) : (excutes with condition is false)\n</code></pre> <pre><code>int x = (10&lt;20) ? 30 : 40;\nSystem.out.println(x); //30\n</code></pre> <p>We can perform nesting of conditional operator as well.</p> <pre><code>int x = (10 &gt; 20) ? 30 : ((40 &gt; 50) ? 60 : 70);\nSystem.out.println(x); // 70\n</code></pre>"},{"location":"operators/equality/","title":"Equality operators (==, !=)","text":"<ul> <li> <p>We can apply equality operators for every primitive type, including boolean.   <pre><code>System.out.println(10 == 20); //false\nSystem.out.println('a' == 'b'); //false\nSystem.out.println('a' == 97.0); //true\nSystem.out.println(false == false); //true\n</code></pre></p> </li> <li> <p>We can apply equality operators for an object type as well.</p> </li> <li> <p>For object reference <code>r1</code> and <code>r2</code> returns true if and only if both references pointing to the same object. (reference comparison/address comparison)   <pre><code>Thread t1 = new Thread();\nThread t2 = new Thread();\nThread t3 = t1;\n\nSystem.out.println(t1 == t2); //false\nSystem.out.println(t1 == t3); //true\n</code></pre></p> </li> <li> <p>If we apply this operator for an object type, then compulsory there should be some relation between argument types    (either child to parent, parent to child or same type) otherwise compile time error will be raised.   <pre><code>Thread t = new Thread();\nObject o = new Object();\nString s = new String(\"Java\");\n\nSystem.out.println(t == o); //false\nSystem.out.println(o == s); //false\nSystem.out.println(s == t); \n//CE: incompatible types, java.lang.String &amp; java.lang.Thread\n</code></pre></p> </li> <li> <p>We can use <code>==</code> operator for reference comparison (address comparison) and equals() method for content comparison.   <pre><code>String s1 = new String(\"java\");\nString s2 = new String(\"java\");\nSystem.out.println(s1 == s2); //false\nSystem.out.println(s1.equals(s2)); //true\n</code></pre></p> </li> <li> <p>For any object reference <code>r</code>, <code>r == null</code> is always false, otherwise r contains <code>null</code> value. <code>null == null</code> is always true.   <pre><code>String s = new String(\"java\");\nSystem.out.println(s == null); //false\n\nString s = null;\nSystem.out.println(s == null); //true\nSystem.out.println(null == null); //true\n</code></pre></p> </li> </ul>"},{"location":"operators/increment-decrement/","title":"Increment &amp; Decrement operators","text":""},{"location":"operators/increment-decrement/#introduction","title":"Introduction","text":""},{"location":"operators/increment-decrement/#increment","title":"Increment","text":""},{"location":"operators/increment-decrement/#pre-increment","title":"Pre-increment","text":"<pre><code>int y = 10;\nint x = ++y;\nSystem.out.println(x); //11\n</code></pre>"},{"location":"operators/increment-decrement/#post-increment","title":"Post-increment","text":"<pre><code>int y = 10;\nint x = y++;\nSystem.out.println(x); //10\n</code></pre>"},{"location":"operators/increment-decrement/#decrement","title":"Decrement","text":""},{"location":"operators/increment-decrement/#pre-decrement","title":"Pre-decrement","text":"<pre><code>int y = 10;\nint x = --y;\nSystem.out.println(x); //9\n</code></pre>"},{"location":"operators/increment-decrement/#post-decrement","title":"Post-decrement","text":"<pre><code>int y = 10;\nint x = y--;\nSystem.out.println(x); //10\n</code></pre>"},{"location":"operators/increment-decrement/#various-cases","title":"Various cases","text":"<ul> <li> <p>We can apply increment and decrement operators only to the variables but not to the constant values, otherwise compile time error will be raised. <pre><code>int x = 10;\nint y = ++x;\nSystem.out.println(y); //11\n\n\nint x = 10;\nint y = ++10; // CE: unsupported type, found: value, required: variable\nSystem.out.println(y);\n</code></pre> </p> </li> <li> <p>Nesting of increment and decrement operators is not allowed. <pre><code>int x = 10;\nint y = ++(++x); //CE: unsupported type, found: value, required: variable\nSystem.out.println(y);\n</code></pre> </p> </li> <li> <p>We can't use increment or decrement operators on the final variable. <pre><code>final int x = 10;\nx++;  // CE: cannot assign a value to final variable x\nSystem.out.println(x);\n</code></pre> </p> </li> <li> <p>Increment and decrement operator can be applied to every primitive type except boolean; <pre><code>int x = 10;\nx++;\nSystem.out.println(x); //11\n\nchar ch = 'a';\nch++;\nSystem.out.println(ch); //b\n\ndouble d = 10.5;\nd++;\nSystem.out.println(d); //11.5\n\nboolean b = true;\nb++; // CE:operator ++ cannot be applied to boolean\nSystem.out.println(b);\n</code></pre></p> </li> </ul>"},{"location":"operators/increment-decrement/#difference-between-b-and-bb1","title":"Difference between b++ and b=b+1","text":"<p>If we apply any arithmetic operator between two variables a and b, the result type is always <code>max(int, type of a, type of b)</code> <pre><code>byte a = 10;\nbyte b = 20;\nbyte c = a + b; //CE: possible loss of precision, found: int, required: byte\nSystem.out.println(c);\n</code></pre></p> <p><pre><code>byte b = 10;\nb = b + 1;  //CE: possible loss of precision, found:int, required: byte\nSystem.out.println(b);\n</code></pre>  In the case of increment and decrement operator, internal type casting will be performed. <code>b++ =&gt;  b=(type of b)(b+1)</code></p> <pre><code>byte b = 10;\nb++;\nSystem.out.println(b); //11\n</code></pre>"},{"location":"operators/instanceof-vs-isinstance/","title":"instanceof vs isInstance()","text":""},{"location":"operators/instanceof-vs-isinstance/#instanceof","title":"<code>instanceof</code>","text":"<ul> <li><code>instnaceof</code> is an operator in Java</li> <li>We can use <code>instanceof</code> to check whether given object is of a particular type. And we know the type at the beginning. <pre><code>Thread t = new Thread();\nSystem.out.println(t instanceof Runnable); //true\nSystem.out.println(t instanceof Object); //true\n</code></pre></li> </ul>"},{"location":"operators/instanceof-vs-isinstance/#isinstance","title":"<code>isInstance()</code>","text":"<ul> <li><code>isInstance()</code> is a method present in <code>java.lang.class</code></li> <li>We can use <code>isInstance()</code> to check whether given object is of a particular type. And we don't know the type at the beginning, and it is available dynamically at runtime. <pre><code>class Test {\n  public static void main(String[] args) {\n    Thread t = new Thread();\n    System.out.println(Class.forName(args[0]).isInstance(t)); \n  }\n}\n\n// &gt; java Test Runnable\n// prints: true\n\n// &gt; java Test String\n// prints: false\n</code></pre></li> </ul> <p><code>isInstance()</code> is equivalent of <code>instanceof</code> operator.</p>"},{"location":"operators/instanceof/","title":"instanceof operator","text":"<p>We can use <code>instanceof</code> operator to check whether given object is of a particular type.</p> <pre><code>Object o = list.get(0);\nif(o instanceof Student) {\n  Student s = (Student)o;\n  //perform student-specific functionality\n} else if(o instanceof Customer) {\n  Customer c = (Customer) o;\n  //perform customer-specific functionality\n}\n</code></pre>"},{"location":"operators/instanceof/#syntax","title":"Syntax","text":"<p><code>r instanceof X</code>, where r is any object reference, X is a class or interface name.</p> <p><pre><code>Thread t = new Thread();\nSystem.out.println(t instanceof Thread); //true\nSystem.out.println(t instanceof Object); //true\nSystem.out.println(t instanceof Runnable); //true\n</code></pre> <pre><code>graph BT\nA[\"Thread\"] --&gt; B[\"Object\"]\nA --&gt; C[\"Runnable\"]</code></pre></p> <ul> <li>To use <code>instanceof</code> operator, compulsory there should be some relation between argument types (either child to parent or parent to child or same type), otherwise compile time error will be raised.   <pre><code>Thread t = new Thread();\nSystem.out.println(t instanceof String);\n//CE: inconvertible types \n//found: java.lang.Thread \n//required: java.lang.String\n</code></pre></li> </ul> <p>Note: For any class or interface X, <code>null instnaceof X</code> is always false.</p>"},{"location":"operators/new-operator/","title":"new operator","text":""},{"location":"operators/new-operator/#new-operator","title":"<code>new</code> operator","text":"<p>We can use <code>new</code> operator to create an object.</p> <p><pre><code>Test t = new Test();\n</code></pre> Note: After creating an object, constructor will be executed to perform initialization of an object. Hence, constructor is not for creation of an object, it is for initialization of an object.</p> <p>We have only <code>new</code> keyword, but not <code>delete</code> keyword, because destruction of useless objects is the responsibility of Garbage Collector (GC).</p>"},{"location":"operators/new-operator/#operator","title":"[] operator","text":"<p>We can use this operator for declaring and creating arrays.</p> <pre><code>int [] x = new int[10];\n</code></pre>"},{"location":"operators/new-vs-new-instance/","title":"new vs newInstance()","text":"<p>We can use <code>new</code> operator to create an object if we know the class name in beginning.</p> <pre><code>Test test = new Test();\n\nStudent student = new Student();\n\nCustomer customer = new Customer();\n</code></pre> <p><code>newInstance()</code> is a method present in class <code>Class</code>. We can use <code>newInstance()</code> to create an object if we don't know the name at beginning, and it is available at runtime.</p> <pre><code>class Student {\n}\nclass Customer {\n\n}\nclass Test {\n  public static void main(String[] args) {\n    Object obj = Class.forName(args[0]).newInstance();  \n    System.out.println(\"object created for \"+obj.getClass().getName());\n  }\n}\n\n// &gt; java Test Student\n// object created for Student\n\n// &gt; java Test Customer\n// object created for Customer\n\n// &gt; java Test java.lang.String\n// object created for java.lang.String\n</code></pre> <p>In the case of <code>new</code> operator, based on requirement, we can invoke any constructor.</p> <pre><code>Test t1 = new Test();\nTest t2 = new Test(10);\nTest t3 = new Test(\"Java\");\n</code></pre> <p>But <code>newInstance()</code>, internally calls no-argument constructor, hence to use <code>newInstance()</code>, compulsory corresponding class should contain no-argument constructor, otherwise runtime exception saying <code>Instantiation Exception</code> will be raised.</p> <p>While using <code>new</code> operator, if corresponding .class file is not available during runtime, then runtime exception saying <code>NoClassDefFoundError</code> will be raised.</p> <p><pre><code>Test t = new Test();\n</code></pre> If <code>Test.class</code> file not available during runtime, then we will get runtime exception saying <code>NoClassDefFoundError</code> </p> <p>While using <code>newInstance()</code>, if corresponding .class file not present at runtime then we will get runtime exception saying <code>ClassNotFoundException</code></p> <p><pre><code>Object obj = Class.forName(args[0]).newInstance();\n\n// &gt; java Test Test123\n</code></pre> If <code>Test123.class</code> file not available during runtime, then runtime exception saying <code>ClassNotFoundException: Test123</code> will be raised.</p>"},{"location":"operators/new-vs-new-instance/#difference-between-new-and-newinstance","title":"Difference between new and newInstance","text":"<code>new</code> <code>newInstance</code> - It is an operator in Java - It is a method present in <code>java.lang.class</code> - We can use <code>new</code> operator to create an object if we know class name at the beginning. - We can use this method to create object if we don't know the class name at the beginning and it is available dynamically at runtime. - It use <code>new</code> operator, class mandatory not required to contain no-arg constructor. - To use <code>newInstance()</code>, compulsory class should contain no-arg constructor otherwise runtime exception will be thrown. - If <code>.class</code> file not available during runtime then runtime exception <code>NoClassDefFoundError</code> will be raised. - If <code>.class</code>  file not available during runtime then runtime exception <code>ClassNotFoundException</code> will be raised."},{"location":"operators/operator-precedence/","title":"Operator Precedence","text":""},{"location":"operators/operator-precedence/#operator-precedence","title":"Operator precedence","text":"<ol> <li>Unary operators <pre><code>[], x++, x--\n++x, --x, ~, !\nnew, &lt;type&gt; (used for type casting)\n</code></pre></li> <li>Arithmetic operators <pre><code>*, /, %\n+, -\n</code></pre></li> <li>Shift operators <pre><code>&gt;&gt;&gt;, &gt;&gt;, &lt;&lt;\n</code></pre></li> <li>Comparison operators <pre><code>&lt;, &lt;=, \\&gt;, \\&gt;=, instanceof\n</code></pre></li> <li> <p>Equality operators <pre><code>==, !=\n</code></pre></p> </li> <li> <p>Bitwise operators <pre><code>&amp;\n^\n|\n</code></pre></p> </li> <li> <p>Short-circuit operators <pre><code>&amp;&amp;\n||\n</code></pre></p> </li> <li> <p>Conditional operators <pre><code>?:\n</code></pre></p> </li> <li> <p>Assignment operators <pre><code>=, +=, -=, *=, ....\n</code></pre></p> </li> </ol>"},{"location":"operators/operator-precedence/#evaluation-order-of-java-operands","title":"Evaluation order of Java operands","text":"<p>There is no precedence for operands; before applying any operator, al operands will be evaluated from left to right.</p> <pre><code>public class EvaluationOrderDemo {\n  public static void main(String[] args) {\n    System.out.println(m1(1)+m1(2)*m1(3)/m1(4)+m1(5)*m1(6));\n  } \n\n  public static int m1(int i) {\n      System.out.println(i);\n      return i;\n  }\n}\n\n//Output\n1\n2\n3\n4\n5\n6\n32\n</code></pre>"},{"location":"operators/relational-operator/","title":"Relational Operators (&lt;, &lt;=, &gt;, &gt;=)","text":"<ul> <li> <p>We can apply relational operators to every primitive type except boolean.   <pre><code>System.out.println(10 &lt; 20); //true\nSystem.out.println('a' &lt; 10); //false\nSystem.out.println('a' &lt; 99.7); //true\nSystem.out.println('a' &lt; 'A'); //true\n\nSystem.out.println(true &gt; false); \n//CE: operator &gt; cannot be applied to boolean, boolean\n</code></pre></p> </li> <li> <p>We can't apply relational operators for object types.   <pre><code>System.out.println(\"java123\" &gt; \"java\"); \n//CE: operator &gt; cannot be applied to\n// java.lang.String, java.lang.String\n</code></pre></p> </li> <li> <p>Nesting of relational operator is not allowed otherwise compile time error will be raised.   <pre><code>System.out.println( 10 &lt; 20 &lt; 30); \n//CE: operator &lt; cannot be applied to boolean, int \n</code></pre></p> </li> </ul>"},{"location":"operators/short-circuit/","title":"Short-circuit Operator","text":""},{"location":"operators/short-circuit/#short-circuit-operators","title":"Short-circuit operators (&amp;&amp;, ||)","text":"<ul> <li>These are exactly the same as bitwise operators (&amp;, |) except the following difference</li> </ul> &amp;, | &amp;&amp;, || -Both arguments should always be evaluated - 2nd argument evaluation is optional. -Relatively low performance -Relatively high performance -Applicable for both boolean &amp; integral types -Applicable only for boolean type. <p>Note: x &amp;&amp; y --&gt; y will be evaluated iff x is true, i.e., if x is false, then y won't be evaluated. x||y --&gt; y will be evaluated iff x is false, i.e., if x is true then y won't be evaluated.</p> <pre><code>int x = 10, y = 15;\n\nif( ++x&lt;10 &amp; ++y&gt;15) {\n  x++;  \n} else {\n    y++\n}\nSystem.out.println(x + \"---\" + y);\n</code></pre> <p>The following output will be returned if we replace operator</p> x y &amp; 11 17 &amp;&amp; 11 16 | 12 16 || 12 16 <pre><code>int x = 10;\nif(++x&lt;10 &amp;&amp; (x/0&gt;10)) {\n    System.out.println(\"Hello\");\n} else {\n    System.out.println(\"Hi\");\n}\n\n// Output: Hi\n</code></pre> <p>Note: If we replace &amp;&amp; with &amp; then runtime exception will be raised with message <code>ArithmeticException: / by zero</code></p>"},{"location":"operators/string-concat/","title":"String concatenation (+)","text":"<p>The only overloaded operator in Java is <code>+</code> operator. Sometimes it acts as arithmetic addition and sometime String concatenation.</p> <p>If at least one argument is String type, then this operator acts as concatenation otherwise arithmetic addition.</p> <p><pre><code>String a = \"java\";\nint b = 10, c = 20, d = 30;\n\nSystem.out.println(a+b+c+d); //java102030\nSystem.out.println(b+c+d+a); //60java\nSystem.out.println(b+c+a+d); //30java30\nSystem.out.println(b+a+c+d); //10java2030\n</code></pre> Here the operators were evaluated from left to right as all having the same precedence.</p> <p>Consider the following declaration, which of the following expressions are valid:</p> <pre><code>String a = \"java\";\nint b = 10, c = 20, d = 30;\n\na = b + c + d; \n//CE: incompatible types, found: int, required: java.lang.String \n\na = a + b + c; //java1020\n\nb = a + c + d; \n//CE: incompatible types: found: java.lang.String, required: int\n\nb = b + c + d; //60\n</code></pre>"},{"location":"operators/type-cast-operator/","title":"Type cast operator","text":"<p>There are two types of type casting</p> <ul> <li>Implicit type casting</li> <li>Explicit type casting</li> </ul>"},{"location":"operators/type-cast-operator/#implicit-type-casting","title":"Implicit type casting","text":"<ul> <li>Compiler is responsible to perform implicit type casting.</li> <li>Whenever we are assigning smaller data type value to bigger data type variable, implicit type casting is performed.</li> <li>It is also known as widening or upcasting.</li> <li>There is no loss of information.</li> </ul> <p>The following are various possible conversions where implicit type casting will be performed.</p> <pre><code>graph LR\nbyte[\"byte&lt;br&gt; (1 byte)\"] --&gt; short[\"short &lt;br&gt;(2 byte)\"]\nshort --&gt; int[\"int &lt;br&gt;(4 byte)\"]\nchar[\"char (2 byte)\"] --&gt; int\nint --&gt; long[\"long &lt;br&gt; (8 byte)\"]\nlong --&gt; float[\"float&lt;br&gt; (4 byte)\"]\nfloat --&gt; double[\"double&lt;br&gt; (8 byte)\"]</code></pre> <pre><code>int x = 'a';\nSystem.out.println(x); //97\n\ndouble d = 10;\nSystem.out.println(d); //10.0\n</code></pre>"},{"location":"operators/type-cast-operator/#explicit-type-casting","title":"Explicit type casting","text":"<ul> <li>Programmer is responsible to perform explicit type casting.</li> <li>Whenever we are assigning bigger data type value to smaller dat type variable, then explicit type is required.</li> <li>It is also known as narrowing or down casting.</li> <li>There may be a chance of loss of information.</li> </ul> <p>The following are various possibilities where explicit type casting is required.</p> <pre><code>graph RL\ndouble[\"double&lt;br&gt; (8 byte)\"] --&gt; float[\"float&lt;br&gt; (4 byte)\"] \nfloat --&gt; long[\"long &lt;br&gt; (8 byte)\"]\nlong --&gt; int[\"int &lt;br&gt;(4 byte)\"]\nint --&gt; short[\"short &lt;br&gt;(2 byte)\"]\nshort --&gt; byte[\"byte&lt;br&gt; (1 byte)\"]\nint --&gt; char[\"char (2 byte)\"]</code></pre> <pre><code>int x = 130;\nbyte b = x;\n//CE: possible loss of precision, found:int, required: byte\n\nbyte b = (byte) x;\nSystem.out.println(b); //-126\n</code></pre> <ul> <li>Whenever we are assigning bigger data type value to smaller data type variable by explicit type casting, the most significant bits will be lost. We have to consider the least significant bits.</li> <li>If we assign floating point values to integral type by explicit type casting, the digits after the decimal point will be lost.</li> </ul> <pre><code>double d = 130.456;\nint a = (int) d;\nSystem.out.println(a); //130\n\nbyte b = (byte) d;\nSystem.out.println(b); //-126\n</code></pre>"}]}